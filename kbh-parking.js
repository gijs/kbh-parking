// Generated by CoffeeScript 1.6.3
(function() {
  var canvasTiles, loadRecent, map, now, parkomatCount, parkomatGet, sinh, tile2coordZoom, updatePoints;

  mapElem.style.width = window.innerWidth + "px";

  mapElem.style.height = window.innerHeight + "px";

  mapElem.style.display = "inline-block";

  mapElem.style.position = "absolute";

  mapElem.style.top = mapElem.style.left = "0px";

  map = L.map('mapElem');

  L.tileLayer('http://{s}.tile.osm.org/{z}/{x}/{y}.png', {
    attribution: '&copy; <a href="http://osm.org/copyright">OpenStreetMap</a> contributors'
  }).addTo(map);

  navigator.geolocation.getCurrentPosition(function(pos) {
    return map.setView([pos.coords.latitude, pos.coords.longitude], 10);
  });

  sinh = function(x) {
    return (Math.pow(Math.E, x) - Math.pow(Math.E, -x)) / 2;
  };

  tile2coordZoom = function(zoom) {
    return function(x, y) {
      var scale;
      scale = Math.pow(0.5, zoom);
      return [x * scale * 360.0 - 180.0, 180 / Math.PI * Math.atan(sinh(Math.PI * (1 - 2 * y * scale)))];
    };
  };

  canvasTiles = L.tileLayer.canvas();

  canvasTiles.drawTile = function(canvas, tilePoint, zoom) {
    var ctx, d, dlat, dlng, dx, dy, im, lat, lng, maxDist, obj, parkomat, tile2coord, w, x, y, _, _i, _j, _k, _l, _ref;
    tile2coord = tile2coordZoom(zoom);
    if (false) {
      ctx = canvas.getContext("2d");
      im = ctx.getImageData(0, 0, 255, 255);
      w = im.width;
      for (y = _i = 0; _i <= 255; y = _i += 2) {
        for (x = _j = 0; _j <= 255; x = _j += 2) {
          _ref = tile2coord(tilePoint.x + x / 256, tilePoint.y + y / 256), lng = _ref[0], lat = _ref[1];
          d = 0;
          maxDist = 10000;
          parkomat = void 0;
          for (_ in points) {
            obj = points[_];
            dlng = obj.lng - lng;
            dlng *= dlng;
            dlat = obj.lat - lat;
            dlat *= dlat;
            if (dlat + dlng < maxDist) {
              maxDist = dlat + dlng;
              parkomat = obj;
            }
          }
          for (dx = _k = 0; _k <= 1; dx = ++_k) {
            for (dy = _l = 0; _l <= 1; dy = ++_l) {
              if (maxDist < 0.01) {
                im.data[4 * (x + dx + (y + dy) * w)] = parkomat.sampling * 256 / 40000;
                im.data[4 * (x + dx + (y + dy) * w) + 1] = parkomat.sampling * 256 / 40000;
                im.data[4 * (x + dx + (y + dy) * w) + 2] = parkomat.sampling * 256 / 40000;
                im.data[4 * (x + dx + (y + dy) * w) + 3] = 100;
              }
            }
          }
        }
      }
      console.log(im, maxDist);
      return ctx.putImageData(im, 0, 0);
    }
    /*
    ctx = canvas.getContext "2d"
    setInterval (->
      ctx.fillRect Math.random() * 256, Math.random() * 256,3,3
    ), 1000
    */

  };

  canvasTiles.addTo(map);

  parkomatGet = function(offset, limit, fn) {
    return $.ajax({
      url: 'http://data.kk.dk/api/action/datastore_search',
      data: {
        resource_id: '660e19fa-8838-4a5c-9495-0d7f94fab51e',
        offset: offset,
        limit: limit
      },
      dataType: 'jsonp',
      success: function(data) {
        var _ref;
        return fn((_ref = data.result) != null ? _ref.records : void 0);
      }
    });
  };

  parkomatCount = function(fn) {
    return $.ajax({
      url: 'http://data.kk.dk/api/action/datastore_search_sql',
      data: {
        sql: 'SELECT COUNT (*) from "660e19fa-8838-4a5c-9495-0d7f94fab51e"'
      },
      dataType: 'jsonp',
      success: function(data) {
        return fn(+data.result.records[0].count);
      }
    });
  };

  loadRecent = function(fn) {
    return parkomatCount(function(n) {
      console.log("count", n);
      return parkomatGet(n - 70000, 70000, function(result) {
        console.log("got n", result.length);
        return fn(result);
      });
    });
  };

  now = void 0;

  updatePoints = function(fn) {
    var parkomat, _;
    for (_ in points) {
      parkomat = points[_];
      parkomat.used = 0;
    }
    return loadRecent(function(events) {
      var current, event, latest, missing, _i, _len;
      console.log(events[0]);
      latest = events.reduce((function(a, b) {
        if (a.tlPayDateTime > b.tlExpDateTime) {
          return a;
        } else {
          return b;
        }
      }), {
        tlPayDateTime: ""
      });
      now = latest.tlPayDateTime;
      missing = 0;
      current = events.filter(function(e) {
        return (e.tlPayDateTime < now && now < e.tlExpDateTime);
      });
      for (_i = 0, _len = current.length; _i < _len; _i++) {
        event = current[_i];
        parkomat = points[event.tlPDM];
        if (parkomat) {
          ++parkomat.used;
        } else {
          ++missing;
        }
      }
      console.log("missing out of", missing, current.length);
      return fn();
    });
  };

  $(function() {
    return updatePoints(function() {
      return void 0;
    });
  });

}).call(this);
